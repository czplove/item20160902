// This file is generated by Ember Desktop.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.



#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "stack/include/error.h"
#include "stack/include/ember-types.h"
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/serial-interface.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST

#include "app/framework/util/util.h"
#include "af-structs.h"
#include "call-command-handler.h"
#include "command-id.h"
#include "callback.h"

static EmberAfStatus status(bool wasHandled, bool clusterExists, bool mfgSpecific)
{
  if (wasHandled) {
    return EMBER_ZCL_STATUS_SUCCESS;
  } else if (mfgSpecific) {
    return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
  } else if (clusterExists) {
    return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  } else {
    return EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER;
  }
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand *cmd)
{
  if (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT
      && emberAfContainsClient(cmd->apsFrame->destinationEndpoint,
                               cmd->apsFrame->clusterId)) {
    switch (cmd->apsFrame->clusterId) {
    case ZCL_IDENTIFY_CLUSTER_ID:
      return emberAfIdentifyClusterClientCommandParse(cmd);
    case ZCL_POLL_CONTROL_CLUSTER_ID:
      return emberAfPollControlClusterClientCommandParse(cmd);
    case ZCL_IAS_ZONE_CLUSTER_ID:
      return emberAfIasZoneClusterClientCommandParse(cmd);
    case ZCL_IAS_ACE_CLUSTER_ID:
      return emberAfIasAceClusterClientCommandParse(cmd);
    case ZCL_SIMPLE_METERING_CLUSTER_ID:
      return emberAfSimpleMeteringClusterClientCommandParse(cmd);
    }
  } else if (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER
             && emberAfContainsServer(cmd->apsFrame->destinationEndpoint,
                                      cmd->apsFrame->clusterId)) {
    switch (cmd->apsFrame->clusterId) {
    case ZCL_IDENTIFY_CLUSTER_ID:
      return emberAfIdentifyClusterServerCommandParse(cmd);
    case ZCL_ON_OFF_CLUSTER_ID:
      return emberAfOnOffClusterServerCommandParse(cmd);
    case ZCL_LEVEL_CONTROL_CLUSTER_ID:
      return emberAfLevelControlClusterServerCommandParse(cmd);
    case ZCL_COLOR_CONTROL_CLUSTER_ID:
      return emberAfColorControlClusterServerCommandParse(cmd);
    case ZCL_IAS_ACE_CLUSTER_ID:
      return emberAfIasAceClusterServerCommandParse(cmd);
    }
  }
  return status(false, false, cmd->mfgSpecific);
}

// Cluster: Identify, client
EmberAfStatus emberAfIdentifyClusterClientCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_IDENTIFY_QUERY_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t timeout;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        timeout = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIdentifyClusterIdentifyQueryResponseCallback(timeout);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Identify, server
EmberAfStatus emberAfIdentifyClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_IDENTIFY_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t identifyTime;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        identifyTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIdentifyClusterIdentifyCallback(identifyTime);
        break;
      }
    case ZCL_IDENTIFY_QUERY_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfIdentifyClusterIdentifyQueryCallback();
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: On/off, server
EmberAfStatus emberAfOnOffClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_OFF_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfOnOffClusterOffCallback();
        break;
      }
    case ZCL_ON_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfOnOffClusterOnCallback();
        break;
      }
    case ZCL_TOGGLE_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfOnOffClusterToggleCallback();
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Level Control, server
EmberAfStatus emberAfLevelControlClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_MOVE_TO_LEVEL_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t level;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfLevelControlClusterMoveToLevelCallback(level,
                                                                   transitionTime);
        break;
      }
    case ZCL_MOVE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t moveMode;  // Ver.: always
        uint8_t rate;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfLevelControlClusterMoveCallback(moveMode,
                                                            rate);
        break;
      }
    case ZCL_STEP_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t stepMode;  // Ver.: always
        uint8_t stepSize;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 4
        if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfLevelControlClusterStepCallback(stepMode,
                                                            stepSize,
                                                            transitionTime);
        break;
      }
    case ZCL_STOP_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfLevelControlClusterStopCallback();
        break;
      }
    case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t level;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfLevelControlClusterMoveToLevelWithOnOffCallback(level,
                                                                            transitionTime);
        break;
      }
    case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t moveMode;  // Ver.: always
        uint8_t rate;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfLevelControlClusterMoveWithOnOffCallback(moveMode,
                                                                     rate);
        break;
      }
    case ZCL_STEP_WITH_ON_OFF_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t stepMode;  // Ver.: always
        uint8_t stepSize;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 4
        if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfLevelControlClusterStepWithOnOffCallback(stepMode,
                                                                     stepSize,
                                                                     transitionTime);
        break;
      }
    case ZCL_STOP_WITH_ON_OFF_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfLevelControlClusterStopWithOnOffCallback();
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Poll Control, client
EmberAfStatus emberAfPollControlClusterClientCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_CHECK_IN_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfPollControlClusterCheckInCallback();
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Color Control, server
EmberAfStatus emberAfColorControlClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_MOVE_TO_HUE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t hue;  // Ver.: always
        uint8_t direction;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 4
        if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        hue = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        direction = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterMoveToHueCallback(hue,
                                                                 direction,
                                                                 transitionTime);
        break;
      }
    case ZCL_MOVE_HUE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t moveMode;  // Ver.: always
        uint8_t rate;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterMoveHueCallback(moveMode,
                                                               rate);
        break;
      }
    case ZCL_STEP_HUE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t stepMode;  // Ver.: always
        uint8_t stepSize;  // Ver.: always
        uint8_t transitionTime;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterStepHueCallback(stepMode,
                                                               stepSize,
                                                               transitionTime);
        break;
      }
    case ZCL_MOVE_TO_SATURATION_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t saturation;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        saturation = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterMoveToSaturationCallback(saturation,
                                                                        transitionTime);
        break;
      }
    case ZCL_MOVE_SATURATION_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t moveMode;  // Ver.: always
        uint8_t rate;  // Ver.: always
        // Command is fixed length: 2
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterMoveSaturationCallback(moveMode,
                                                                      rate);
        break;
      }
    case ZCL_STEP_SATURATION_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t stepMode;  // Ver.: always
        uint8_t stepSize;  // Ver.: always
        uint8_t transitionTime;  // Ver.: always
        // Command is fixed length: 3
        if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterStepSaturationCallback(stepMode,
                                                                      stepSize,
                                                                      transitionTime);
        break;
      }
    case ZCL_MOVE_TO_HUE_AND_SATURATION_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t hue;  // Ver.: always
        uint8_t saturation;  // Ver.: always
        uint16_t transitionTime;  // Ver.: always
        // Command is fixed length: 4
        if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        hue = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        saturation = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfColorControlClusterMoveToHueAndSaturationCallback(hue,
                                                                              saturation,
                                                                              transitionTime);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: IAS Zone, client
EmberAfStatus emberAfIasZoneClusterClientCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_ZONE_STATUS_CHANGE_NOTIFICATION_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t zoneStatus;  // Ver.: always
        uint8_t extendedStatus;  // Ver.: always
        uint8_t zoneId;  // Ver.: since ha-1.2-05-3520-29
        uint16_t delay;  // Ver.: since ha-1.2-05-3520-29
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneStatus = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        extendedStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if ( ( cmd->bufLen < payloadOffset + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2-05-3520-29
          zoneId = 0xFF;
        } else {
          zoneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
          payloadOffset += 1;
        }
        if ( ( cmd->bufLen < payloadOffset + 2)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2-05-3520-29
          delay = 0xFFFF;
        } else {
          delay = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        }
        wasHandled = emberAfIasZoneClusterZoneStatusChangeNotificationCallback(zoneStatus,
                                                                               extendedStatus,
                                                                               zoneId,
                                                                               delay);
        break;
      }
    case ZCL_ZONE_ENROLL_REQUEST_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t zoneType;  // Ver.: always
        uint16_t manufacturerCode;  // Ver.: always
        // Command is fixed length: 4
        if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneType = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        manufacturerCode = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIasZoneClusterZoneEnrollRequestCallback(zoneType,
                                                                    manufacturerCode);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: IAS ACE, client
EmberAfStatus emberAfIasAceClusterClientCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_ARM_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t armNotification;  // Ver.: always
        // Command is fixed length: 1
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        armNotification = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIasAceClusterArmResponseCallback(armNotification);
        break;
      }
    case ZCL_GET_ZONE_ID_MAP_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint16_t section0;  // Ver.: always
        uint16_t section1;  // Ver.: always
        uint16_t section2;  // Ver.: always
        uint16_t section3;  // Ver.: always
        uint16_t section4;  // Ver.: always
        uint16_t section5;  // Ver.: always
        uint16_t section6;  // Ver.: always
        uint16_t section7;  // Ver.: always
        uint16_t section8;  // Ver.: always
        uint16_t section9;  // Ver.: always
        uint16_t section10;  // Ver.: always
        uint16_t section11;  // Ver.: always
        uint16_t section12;  // Ver.: always
        uint16_t section13;  // Ver.: always
        uint16_t section14;  // Ver.: always
        uint16_t section15;  // Ver.: always
        // Command is fixed length: 32
        if (cmd->bufLen < payloadOffset + 32) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        section0 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section1 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section2 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section3 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section4 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section5 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section6 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section7 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section8 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section9 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section10 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section11 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section12 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section13 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section14 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        section15 = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIasAceClusterGetZoneIdMapResponseCallback(section0,
                                                                      section1,
                                                                      section2,
                                                                      section3,
                                                                      section4,
                                                                      section5,
                                                                      section6,
                                                                      section7,
                                                                      section8,
                                                                      section9,
                                                                      section10,
                                                                      section11,
                                                                      section12,
                                                                      section13,
                                                                      section14,
                                                                      section15);
        break;
      }
    case ZCL_GET_ZONE_INFORMATION_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t zoneId;  // Ver.: always
        uint16_t zoneType;  // Ver.: always
        uint8_t* ieeeAddress;  // Ver.: always
        uint8_t* zoneLabel;  // Ver.: since ha-1.2.1-05-3520-30
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneType = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if (cmd->bufLen < payloadOffset + 8) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        ieeeAddress = cmd->buffer + payloadOffset;
        payloadOffset += 8;
        if ( ( cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2.1-05-3520-30
          zoneLabel = NULL;
        } else {
          zoneLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
        }
        wasHandled = emberAfIasAceClusterGetZoneInformationResponseCallback(zoneId,
                                                                            zoneType,
                                                                            ieeeAddress,
                                                                            zoneLabel);
        break;
      }
    case ZCL_ZONE_STATUS_CHANGED_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t zoneId;  // Ver.: always
        uint16_t zoneStatus;  // Ver.: always
        uint8_t audibleNotification;  // Ver.: since ha-1.2.1-05-3520-30
        uint8_t* zoneLabel;  // Ver.: since ha-1.2.1-05-3520-30
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneStatus = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 2;
        if ( ( cmd->bufLen < payloadOffset + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2.1-05-3520-30
          audibleNotification = 0xFF;
        } else {
          audibleNotification = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
          payloadOffset += 1;
        }
        if ( ( cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2.1-05-3520-30
          zoneLabel = NULL;
        } else {
          zoneLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
        }
        wasHandled = emberAfIasAceClusterZoneStatusChangedCallback(zoneId,
                                                                   zoneStatus,
                                                                   audibleNotification,
                                                                   zoneLabel);
        break;
      }
    case ZCL_PANEL_STATUS_CHANGED_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t panelStatus;  // Ver.: always
        uint8_t secondsRemaining;  // Ver.: always
        uint8_t audibleNotification;  // Ver.: since ha-1.2.1-05-3520-30
        uint8_t alarmStatus;  // Ver.: since ha-1.2.1-05-3520-30
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        panelStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        secondsRemaining = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if ( ( cmd->bufLen < payloadOffset + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2.1-05-3520-30
          audibleNotification = 0xFF;
        } else {
          audibleNotification = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
          payloadOffset += 1;
        }
        if ( ( cmd->bufLen < payloadOffset + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2.1-05-3520-30
          alarmStatus = 0xFF;
        } else {
          alarmStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        }
        wasHandled = emberAfIasAceClusterPanelStatusChangedCallback(panelStatus,
                                                                    secondsRemaining,
                                                                    audibleNotification,
                                                                    alarmStatus);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: IAS ACE, server
EmberAfStatus emberAfIasAceClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_ARM_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t armMode;  // Ver.: always
        uint8_t* armDisarmCode;  // Ver.: since ha-1.2-05-3520-29
        uint8_t zoneId;  // Ver.: since ha-1.2-05-3520-29
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        armMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        if ( ( cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2-05-3520-29
          armDisarmCode = NULL;
        } else {
          armDisarmCode = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
          payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1;
        }
        if ( ( cmd->bufLen < payloadOffset + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2-05-3520-29
          zoneId = 0xFF;
        } else {
          zoneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        }
        wasHandled = emberAfIasAceClusterArmCallback(armMode,
                                                     armDisarmCode,
                                                     zoneId);
        break;
      }
    case ZCL_BYPASS_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t numberOfZones;  // Ver.: always
        uint8_t* zoneIds;  // Ver.: always
        uint8_t* armDisarmCode;  // Ver.: since ha-1.2.1-05-3520-30
        // Command is not a fixed length
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        numberOfZones = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        zoneIds = cmd->buffer + payloadOffset;
        payloadOffset += numberOfZones * sizeof(uint8_t);
        if ( ( cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1)) {
          // Argument is not always present:
          // - it is present only in versions higher than: ha-1.2.1-05-3520-30
          armDisarmCode = NULL;
        } else {
          armDisarmCode = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
        }
        wasHandled = emberAfIasAceClusterBypassCallback(numberOfZones,
                                                        zoneIds,
                                                        armDisarmCode);
        break;
      }
    case ZCL_EMERGENCY_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfIasAceClusterEmergencyCallback();
        break;
      }
    case ZCL_FIRE_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfIasAceClusterFireCallback();
        break;
      }
    case ZCL_PANIC_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfIasAceClusterPanicCallback();
        break;
      }
    case ZCL_GET_ZONE_ID_MAP_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfIasAceClusterGetZoneIdMapCallback();
        break;
      }
    case ZCL_GET_ZONE_INFORMATION_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t zoneId;  // Ver.: always
        // Command is fixed length: 1
        if (cmd->bufLen < payloadOffset + 1) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        zoneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfIasAceClusterGetZoneInformationCallback(zoneId);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, client
EmberAfStatus emberAfSimpleMeteringClusterClientCommandParse(EmberAfClusterCommand *cmd)
{
  bool wasHandled = false;
  if (!cmd->mfgSpecific) {
    switch (cmd->commandId) {
    case ZCL_GET_PROFILE_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint32_t endTime;  // Ver.: always
        uint8_t status;  // Ver.: always
        uint8_t profileIntervalPeriod;  // Ver.: always
        uint8_t numberOfPeriodsDelivered;  // Ver.: always
        uint8_t* intervals;  // Ver.: always
        // Command is fixed length: 7
        if (cmd->bufLen < payloadOffset + 7) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 4;
        status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        profileIntervalPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        numberOfPeriodsDelivered = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        intervals = cmd->buffer + payloadOffset;
        wasHandled = emberAfSimpleMeteringClusterGetProfileResponseCallback(endTime,
                                                                            status,
                                                                            profileIntervalPeriod,
                                                                            numberOfPeriodsDelivered,
                                                                            intervals);
        break;
      }
    case ZCL_REQUEST_MIRROR_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfSimpleMeteringClusterRequestMirrorCallback();
        break;
      }
    case ZCL_REMOVE_MIRROR_COMMAND_ID:
      {
        // Command is fixed length: 0
        wasHandled = emberAfSimpleMeteringClusterRemoveMirrorCallback();
        break;
      }
    case ZCL_REQUEST_FAST_POLL_MODE_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint8_t appliedUpdatePeriod;  // Ver.: always
        uint32_t fastPollModeEndtime;  // Ver.: always
        // Command is fixed length: 5
        if (cmd->bufLen < payloadOffset + 5) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        appliedUpdatePeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 1;
        fastPollModeEndtime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfSimpleMeteringClusterRequestFastPollModeResponseCallback(appliedUpdatePeriod,
                                                                                     fastPollModeEndtime);
        break;
      }
    case ZCL_SUPPLY_STATUS_RESPONSE_COMMAND_ID:
      {
        uint16_t payloadOffset = cmd->payloadStartIndex;
        uint32_t providerId;  // Ver.: always
        uint32_t issuerEventId;  // Ver.: always
        uint32_t implementationDateTime;  // Ver.: always
        uint8_t supplyStatus;  // Ver.: always
        // Command is fixed length: 13
        if (cmd->bufLen < payloadOffset + 13) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
        providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 4;
        issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 4;
        implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
        payloadOffset += 4;
        supplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
        wasHandled = emberAfSimpleMeteringClusterSupplyStatusResponseCallback(providerId,
                                                                              issuerEventId,
                                                                              implementationDateTime,
                                                                              supplyStatus);
        break;
      }
    }
  }
  return status(wasHandled, true, cmd->mfgSpecific);
}
